[{"authors":["admin"],"categories":null,"content":"SyDPaCC is a set of libraries for the Coq proof assistant. It allows to write naive functional programs (i.e. with high complexity) that are considered as specifications, and to transform them into more efficient versions. These more efficient versions can then be automatically parallelized before being extracted from Coq into source code for the functional language OCaml together with calls to the Bulk Synchronous Parallel ML (BSML) library.\nFor the optimization of sequential functions, SyDPaCC provides theorems such a the second homomorphism theorem that states that a homomorphic function is equivalent to a composition of map and reduce.\nSyDPaCC also provides a set of algorithmic skeletons, programmed using BSML, and proved correct with respect to sequential functions. Algorithmic skeletons are higher-order function implemented in parallel, such as map and reduce but on distributed data structures. The way the correctness is stated is the basis of the automatic parallelization feature of SyDPaCC.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"https://sypdacc.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"author","summary":"SyDPaCC is a set of libraries for the Coq proof assistant. It allows to write naive functional programs (i.e. with high complexity) that are considered as specifications, and to transform them into more efficient versions. These more efficient versions can then be automatically parallelized before being extracted from Coq into source code for the functional language OCaml together with calls to the Bulk Synchronous Parallel ML (BSML) library.\nFor the optimization of sequential functions, SyDPaCC provides theorems such a the second homomorphism theorem that states that a homomorphic function is equivalent to a composition of map and reduce.","tags":null,"title":"SyDPaCC","type":"author"},{"authors":null,"categories":null,"content":"","date":1540549800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1540549800,"objectID":"cec91579b06757d73d17c9fa56b3e132","permalink":"https://sypdacc.github.io/team/frederic_loulergue/","publishdate":"2018-10-26T12:30:00+02:00","relpermalink":"/team/frederic_loulergue/","section":"team","summary":"Professor, Université d'Orléans","tags":["faculty","current"],"title":"Frédéric Loulergue","type":"team"},{"authors":null,"categories":null,"content":"","date":1540549800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1540549800,"objectID":"8cf54e77de3b154a38994811da07260a","permalink":"https://sypdacc.github.io/team/julien_tesson/","publishdate":"2018-10-26T12:30:00+02:00","relpermalink":"/team/julien_tesson/","section":"team","summary":"Research Engineer, Nomadic Development","tags":["faculty","alumni"],"title":"Julien Tesson","type":"team"},{"authors":null,"categories":null,"content":"","date":1540549800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1540549800,"objectID":"62f42e8569a5ee8a286c7f9d36943a17","permalink":"https://sypdacc.github.io/team/wadoud_bousdira/","publishdate":"2018-10-26T12:30:00+02:00","relpermalink":"/team/wadoud_bousdira/","section":"team","summary":"Associate Professor, Université d'Orléans","tags":["faculty","current"],"title":"Wadoud Bousdira","type":"team"},{"authors":null,"categories":null,"content":"","date":1540504800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1540504800,"objectID":"358d4c4987e37a0a58aef5be55c49618","permalink":"https://sypdacc.github.io/team/jp2589/","publishdate":"2018-10-26T00:00:00+02:00","relpermalink":"/team/jp2589/","section":"team","summary":"Graduate Research Assistant, Northern Arizona University","tags":["student","alumni"],"title":"Jolan Philippe","type":"team"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"b4c7f25d5b7963758e82d0980c48943b","permalink":"https://sypdacc.github.io/contact/contact/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/contact/contact/","section":"contact","summary":"","tags":null,"title":"Contact","type":"contact"},{"authors":null,"categories":null,"content":"","date":1540549800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1540549800,"objectID":"f95dfc6f798a628eaca5efe5a156b691","permalink":"https://sypdacc.github.io/team/chris_whitney/","publishdate":"2018-10-26T12:30:00+02:00","relpermalink":"/team/chris_whitney/","section":"team","summary":"Undergraduate Research Assistant, Northern Arizona University","tags":["alumni"],"title":"Chris D. Whitney","type":"team"},{"authors":null,"categories":null,"content":"","date":1540549800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1540549800,"objectID":"704033b2f97e361adbb82edbc9bbf284","permalink":"https://sypdacc.github.io/team/kento_emoto/","publishdate":"2018-10-26T12:30:00+02:00","relpermalink":"/team/kento_emoto/","section":"team","summary":"Associate Professor, Kyushu Institute of Technology","tags":["alumni"],"title":"Kento Emoto","type":"team"},{"authors":null,"categories":null,"content":"Louis holds a PhD from University Paris Est, and has studied at EnsIIE, University of Manchester and University of Tokyo. He has a strong background on programming languages and distribution, and was one of the architects behind the Opa language developed at MLstate. Finally, he joined OCamlPro in November 2012.\n","date":1540549800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1540549800,"objectID":"5901bcf01afeede68ebc56ee2dc985b8","permalink":"https://sypdacc.github.io/team/louis_gesbert/","publishdate":"2018-10-26T12:30:00+02:00","relpermalink":"/team/louis_gesbert/","section":"team","summary":"PhD Student, Université Paris Est","tags":["alumni"],"title":"Louis Gesbert","type":"team"},{"authors":["Jolan Philippe","Frédéric Loulergue"],"categories":null,"content":"","date":1546297200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546297200,"objectID":"8fb4f3d30dd9d4283d81dcea2edec8e7","permalink":"https://sypdacc.github.io/publication/pl2019_sac.bib/","publishdate":"2019-01-01T00:00:00+01:00","relpermalink":"/publication/pl2019_sac.bib/","section":"publication","summary":"","tags":null,"title":"Parallel Programming with Coq: Map and Reduce Skeletons on Trees","type":"publication"},{"authors":["Frédéric Loulergue","Christopher D. Whitney"],"categories":null,"content":"","date":1514761200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1514761200,"objectID":"d9ba18e029351837ea0e634e50098a87","permalink":"https://sypdacc.github.io/publication/lw2018_atc.bib/","publishdate":"2018-01-01T00:00:00+01:00","relpermalink":"/publication/lw2018_atc.bib/","section":"publication","summary":"Frequent itemset mining is one pillar of machine learning and is very important for many data mining applications. There are many different algorithms for frequent itemset mining, but to our knowledge no implementation has been proven correct using computer aided verification. Hu et al. derived on paper an efficient algorithm for this problem, starting from an inefficient functional program and by using program calculation derived an efficient version. Based on their work, we propose a formally verified functional implementation for frequent itemset mining developed with the Coq proof assistant. All the proposed programs are evaluated on classical datasets and are compared to a non verified Java implementation of the Apriori algorithm.  ","tags":null,"title":"Verified Programs for Frequent Itemset Mining","type":"publication"},{"authors":["Frédéric Loulergue"],"categories":null,"content":"","date":1483225200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483225200,"objectID":"cabfaa52fc4381b7400f91d413eafd8c","permalink":"https://sypdacc.github.io/publication/lou2017_candar.bib/","publishdate":"2017-01-01T00:00:00+01:00","relpermalink":"/publication/lou2017_candar.bib/","section":"publication","summary":"This paper presents an extension of a library for the Coq interactive theorem prover that enables the development of correct functional parallel programs based on sequential program transformation and automatic parallelization using an algorithmic skeleton named accumulate.  Such an algorithmic skeleton is a pattern of a parallel algorithm that is provided as a high-order function implemented in parallel. The use of this framework is illustrated with the bracket matching problem, including experiments on a parallel machine.","tags":null,"title":"A Verified Accumulate Algorithmic Skeleton","type":"publication"},{"authors":["Frédéric Loulergue","Wadoud Bousdira","Julien Tesson"],"categories":null,"content":"","date":1483225200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483225200,"objectID":"214ece2803d47e0f84b7a9299bc23b72","permalink":"https://sypdacc.github.io/publication/lbt2015_ijpp.bib/","publishdate":"2017-01-01T00:00:00+01:00","relpermalink":"/publication/lbt2015_ijpp.bib/","section":"publication","summary":"SyDPaCC is a set of libraries for the Coq proof assistant. It allows to write naive functional programs (i.e. with high complexity) that are considered as specifications, and to transform them into more efficient versions. These more efficient versions can then be automatically parallelised before being extracted from Coq into source code for the functional language OCaml together with calls to the Bulk Synchronous Parallel ML (BSML) library. In this paper we present a new core version of SyDPaCC for the development of parallel programs correct-by-contruction using the theory of list homomorphisms and algorithmic skeletons implemented and verified in Coq. The framework is illustrated on the the maximum prefix sum problem.","tags":null,"title":"Calculating Parallel Programs in Coq using List Homomorphisms","type":"publication"},{"authors":["Jolan Philippe","Frédéric Loulergue","Wadoud Bousdira"],"categories":null,"content":"","date":1483225200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483225200,"objectID":"8978c001a0fd508c2ce22d3db41ff811","permalink":"https://sypdacc.github.io/publication/plb2017_hpcs.bib/","publishdate":"2017-01-01T00:00:00+01:00","relpermalink":"/publication/plb2017_hpcs.bib/","section":"publication","summary":"","tags":null,"title":"Formalization of a Big Graph API in Coq (Poster)","type":"publication"},{"authors":["Frédéric Loulergue"],"categories":null,"content":"","date":1483225200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483225200,"objectID":"0ba43ce1433b06ebc70a8a69198366fe","permalink":"https://sypdacc.github.io/publication/lou2017_hpcs.bib/","publishdate":"2017-01-01T00:00:00+01:00","relpermalink":"/publication/lou2017_hpcs.bib/","section":"publication","summary":" The SyDPaCC system is a set of libraries for the pr oof assistant Coq that allows to write naive (i.e. inef fi cient) functional programs then to transform them into ef fi cient versions that could be automatically parallelized within the framework before being extracted from Coq to code in the functional language OCaml plus calls to the parallel functional programming library Bulk Synchronous Parallel ML.  These goals of the tutorial are to provide an introduction to the development of correct-by-construction parallel programs, and to able the attendees to develop functio nal parallel programs using the SYDPACC system and the Coq proof assistant.  ","tags":null,"title":"Systematic Development of Programs for Scalable Computing Using Coq (Tutorial)","type":"publication"},{"authors":["Christopher D. Whitney","Frédéric Loulergue"],"categories":null,"content":"","date":1483225200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483225200,"objectID":"4eb0d5c407eef8cec05ac5792e25f9df","permalink":"https://sypdacc.github.io/publication/wl2017_hpcs.bib/","publishdate":"2017-01-01T00:00:00+01:00","relpermalink":"/publication/wl2017_hpcs.bib/","section":"publication","summary":"","tags":null,"title":"Towards a Verified Parallel Implementation of Frequent Itemset Mining (Poster)","type":"publication"},{"authors":["Frédéric Loulergue"],"categories":null,"content":"","date":1451602800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1451602800,"objectID":"14fba5161123c08ca7359431d7a7bb87","permalink":"https://sypdacc.github.io/publication/lou2016_sac.bib/","publishdate":"2016-01-01T00:00:00+01:00","relpermalink":"/publication/lou2016_sac.bib/","section":"publication","summary":" The SyDPaCC system is a set of libraries for the pr oof assistant Coq that allows to write naive (i.e. inef fi cient) functional programs then to transform them into ef fi cient versions that could be automatically parallelized within the framework before being extracted from Coq to code in the functional language OCaml plus calls to the parallel functional programming library Bulk Synchronous Parallel ML.  These goals of the tutorial are to provide an introduction to the development of correct-by-construction parallel programs, and to able the attendees to develop functio nal parallel programs using the SYDPACC system and the Coq proof assistant.  ","tags":null,"title":"Development of Correct-by-Construction Functional Parallel Programs (Tutorial)","type":"publication"},{"authors":["Frédéric Loulergue","Wadoud Bousdira","Julien Tesson"],"categories":null,"content":"","date":1420066800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1420066800,"objectID":"2de97ff2e10e3eb0b6bb65dcf2bb02d3","permalink":"https://sypdacc.github.io/publication/lbt2015_ejcim.bib/","publishdate":"2015-01-01T00:00:00+01:00","relpermalink":"/publication/lbt2015_ejcim.bib/","section":"publication","summary":"","tags":null,"title":"Calcul de programmes parallèles avec Coq","type":"publication"},{"authors":["Kento Emoto","Frédéric Loulergue","Julien Tesson"],"categories":null,"content":"","date":1388530800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1388530800,"objectID":"cc184a9647d4a14c506bdd2a70116d31","permalink":"https://sypdacc.github.io/publication/elt2014_itp.bib/","publishdate":"2014-01-01T00:00:00+01:00","relpermalink":"/publication/elt2014_itp.bib/","section":"publication","summary":"The integration of the generate-and-test paradigm and semi-rings for the aggregation of results provides a parallel programming framework for large scale data-intensive applications. The so-called GTA framework allows a user to define an inefficient specification of his/her problem as a composition of a generator of all the candidate solutions, a tester of valid solutions, and an aggregator to combine the solutions. Through two calculation theorems a GTA specification is transformed into a divide-and-conquer efficient program that can be implemented in parallel. In this paper we present a verified implementation of this framework in the Coq proof assistant: efficient bulk synchronous parallel functional programs can be extracted from naive GTA specifications. We show how to apply this framework on an example, including performance experiments on parallel machines.","tags":null,"title":"A Verified Generate-Test-Aggregate Coq Library for Parallel Programs Extraction","type":"publication"},{"authors":["Frédéric Loulergue","Julien Tesson"],"categories":null,"content":"","date":1388530800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1388530800,"objectID":"72752607dc224d2c3a3f21b50140cc4d","permalink":"https://sypdacc.github.io/publication/lt2014_hpcs.bib/","publishdate":"2014-01-01T00:00:00+01:00","relpermalink":"/publication/lt2014_hpcs.bib/","section":"publication","summary":"With the current generalization of parallel architectures and increasing requirement of parallel computation arises the concern of applying formal methods, which allow specifications of parallel and distributed programs to be precisely stated and the conformance of an implementation to be verified using mathematical techniques. However, the complexity of parallel programs, compared to sequential ones, makes them more error-prone and difficult to verify.  This calls for a strongly structured form of parallelism which should not only be equipped with an abstraction or model that conceals much of the complexity of parallel computation, but also provide a systematic way of developing such parallelism from specifications for practically nontrivial examples.  Transformational programming is a methodology that offers some scope for making the construction of efficient programs more mathematical.  Program calculation is a kind of program transformation based on the theory of constructive algorithmics.  An efficient program is derived step-by-step through a sequence of transformations that preserve the meaning and hence the correctness. With suitable data-structures, program calculation can be used for writing parallel programs.  However, once an efficient (and correct with respect to the initial specification) formulation of the program is obtained through transformations, the program is then implemented using a parallel library of algorithmic skeletons most of the time written in C++ with calls to a communication library such as MPI.  There is no formal correspondence between the efficient program obtained by transformation and the C++ skeletal program. Moreover the transformation itself is usually a pen-and-paper process that could contain errors.  The textscSyDPaCC system is a set of libraries for the Coq proof assistant that allows to write naive functional programs then to transform them into efficient versions that could be automatically parallelised within the framework before being extracted from Coq to real code in the functional language OCaml plus calls to the parallel functional programming library Bulk Synchronous Parallel ML The tutorial is an introduction to the Coq proof assistant and the textscSyDPaCC system for the systematic development of correct and verified parallel programs. ","tags":null,"title":"Certified Parallel Program Calculation in Coq: A Tutorial","type":"publication"},{"authors":["Frédéric Loulergue","Simon Robillard","Julien Tesson","Joeffrey Légaux","Zhenjiang Hu"],"categories":null,"content":"","date":1388530800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1388530800,"objectID":"1cfb8e3b9af6ff0f64fa79d39bc387e7","permalink":"https://sypdacc.github.io/publication/lrt2014_sac.bib/","publishdate":"2014-01-01T00:00:00+01:00","relpermalink":"/publication/lrt2014_sac.bib/","section":"publication","summary":"The All Nearest Smaller Values (ANSV) problem is an important problem for parallel programming as it can be used to solve several problems and is one of the phases of several other parallel algorithms. We formally develop by construction a functional parallel program for solving the ANSV problem using the theory of Bulk Synchronous Parallel (BSP) homomorphisms within the Coq proof assistant. The performances of the Bulk Synchronous Parallel ML program obtained from Coq is compared to a version derived without software support (pen-and-paper) and implemented using the Orléans Skeleton Library of algorithmic skeletons, and to a (unproved correct) direct implementation of the BSP algorithm of He and Huang.  ","tags":null,"title":"Formal Derivation and Extraction of a Parallel Program for the All Nearest Smaller Values Problem","type":"publication"},{"authors":["Frédéric Loulergue","Virginia Niculescu","Simon Robillard"],"categories":null,"content":"","date":1356994800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1356994800,"objectID":"a3da9014446870094575b9480389c938","permalink":"https://sypdacc.github.io/publication/lnr2013_candar.bib/","publishdate":"2013-01-01T00:00:00+01:00","relpermalink":"/publication/lnr2013_candar.bib/","section":"publication","summary":"For parallel programs, correctness by construction is an essential feature since debugging is almost impossible. Building correct programs by construction is not a simple task, and usually the methodologies used for this purpose are rather theoretical and based on a pen-and-paper style. A better approach could be based on tools and theories that allow a user to develop an efficient parallel application by easily implementing simple programs satisfying conditions, ideally automatically proved. Powerlists theory and its variants represent a good theoretical base for such an approach, and the Coq proof assistant is a tool that could be used for automatic proofs. The goal of this paper is to model the powerlist theory in Coq, and to use this modelling to program and reason about parallel programs in Coq. This represents the first step in building a framework to ease the development of correct and verifiable parallel programs.","tags":null,"title":"Powerlists in Coq: Programming and Reasoning","type":"publication"},{"authors":["Wadoud Bousdira","Frédéric Loulergue","Julien Tesson"],"categories":null,"content":"","date":1325372400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1325372400,"objectID":"a80ea09989f0d05eff119bda97d03ef9","permalink":"https://sypdacc.github.io/publication/blt2012_ica3pp.bib/","publishdate":"2012-01-01T00:00:00+01:00","relpermalink":"/publication/blt2012_ica3pp.bib/","section":"publication","summary":"To make parallel programming as widespread as parallel architectures, more structured parallel programming paradigms are necessary.  One of the possible approaches are Algorithmic skeletons that are abstract parallel patterns. They can be seen as higher order functions implemented in parallel. Algorithmic skeletons offer a simple interface to the programmer without all the details of parallel implementations as they abstract the communications and the synchronisations of parallel activities.  To write a parallel program, users have to combine and compose the skeletons.  Orléans Skeleton Library (OSL) is an efficient meta-programmed C++ library of algorithmic skeletons that manipulate distributed arrays.  A prototype implementation of OSL exists as a library written with the function parallel language Bulk Synchronous Parallel ML. In this paper we are interested in verifying the correctness of a subset of this prototype implementation. To do so, we give a functional specification (i.e. without the parallel details) of a subset of OSL and we prove the correctness of the BSML implementation with respect to this functional specification, using the Coq proof assistant. To illustrate how the user could use these skeletons, we prove the correctness of two applications implemented with them: a heat diffusion simulation and the maximum segment sum problem.","tags":null,"title":"A Verified Library of Algorithmic Skeletons on Evenly Distributed Arrays","type":"publication"},{"authors":["Julien Tesson","Frédéric Loulergue"],"categories":null,"content":"","date":1293836400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1293836400,"objectID":"719f06d1233341c56d041159b3596750","permalink":"https://sypdacc.github.io/publication/tl2011_iccs.bib/","publishdate":"2011-01-01T00:00:00+01:00","relpermalink":"/publication/tl2011_iccs.bib/","section":"publication","summary":"Bulk Synchronous Parallel ML (BSML) is a structured parallel functional programming language. It extends a functional programming language of the ML family with a polymorphic data structure and a very small set of primitives. In this paper we describe a framework for reasoning about BSML programs using the Coq interactive theorem prover and for extracting actual parallel programs from proofs. This framework is illustrated through a simulation application based on heat equation.","tags":null,"title":"A Verified Bulk Synchronous Parallel ML Heat Diffusion Simulation","type":"publication"},{"authors":["Julien Tesson"],"categories":null,"content":"","date":1293836400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1293836400,"objectID":"17680156cdc2b0058ca0e4cea995bf4d","permalink":"https://sypdacc.github.io/publication/tes2011_thesis.bib/","publishdate":"2011-01-01T00:00:00+01:00","relpermalink":"/publication/tes2011_thesis.bib/","section":"publication","summary":"","tags":null,"title":"Environnement pour le développement et la preuve de correction systématiques de programmes parallèles fonctionnels","type":"publication"},{"authors":["Julien Tesson","H. Hashimoto","Zhenjiang Hu","Frédéric Loulergue","Masato Takeichi"],"categories":null,"content":"","date":1262300400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1262300400,"objectID":"9f70de08ccde2607a3a978ee9edb5e11","permalink":"https://sypdacc.github.io/publication/thh2010_amast.bib/","publishdate":"2010-01-01T00:00:00+01:00","relpermalink":"/publication/thh2010_amast.bib/","section":"publication","summary":"Program calculation, being a programming technique that derives programs from specification by means of formula manipulation, is a challenging activity. It requires human insights and creativity, and needs systems to help human to focus on clever parts of the derivation by automating tedious ones and verifying correctness of transformations. Different from many existing systems, we show in this paper that Coq, a popular theorem prover, provides a cheap way to implement a powerful system to support program calculation, which has not been recognized so far. We design and implement a set of tactics for the Coq proof assistant to help the user to derive programs by program calculation and to write proofs in calculational form. The use of these tactics is demonstrated through program calculations in Coq based on the theory of lists.  ","tags":null,"title":"Program Calculation in Coq","type":"publication"}]